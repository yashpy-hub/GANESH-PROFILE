/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import fs from 'fs';
import path from 'path';
import * as Diff from 'diff';
import { ApprovalMode } from '../config/config.js';
import { BaseTool, ToolConfirmationOutcome, Kind, } from './tools.js';
import { ToolErrorType } from './tool-error.js';
import { SchemaValidator } from '../utils/schemaValidator.js';
import { makeRelative, shortenPath } from '../utils/paths.js';
import { getErrorMessage, isNodeError } from '../utils/errors.js';
import { ensureCorrectEdit, ensureCorrectFileContent, } from '../utils/editCorrector.js';
import { DEFAULT_DIFF_OPTIONS, getDiffStat } from './diffOptions.js';
import { getSpecificMimeType } from '../utils/fileUtils.js';
import { recordFileOperationMetric, FileOperation, } from '../telemetry/metrics.js';
import { IDEConnectionStatus } from '../ide/ide-client.js';
/**
 * Implementation of the WriteFile tool logic
 */
export class WriteFileTool extends BaseTool {
    config;
    static Name = 'write_file';
    constructor(config) {
        super(WriteFileTool.Name, 'WriteFile', `Writes content to a specified file in the local filesystem.

      The user has the ability to modify \`content\`. If modified, this will be stated in the response.`, Kind.Edit, {
            properties: {
                file_path: {
                    description: "The absolute path to the file to write to (e.g., '/home/user/project/file.txt'). Relative paths are not supported.",
                    type: 'string',
                },
                content: {
                    description: 'The content to write to the file.',
                    type: 'string',
                },
            },
            required: ['file_path', 'content'],
            type: 'object',
        });
        this.config = config;
    }
    toolLocations(params) {
        return [{ path: params.file_path }];
    }
    validateToolParams(params) {
        const errors = SchemaValidator.validate(this.schema.parametersJsonSchema, params);
        if (errors) {
            return errors;
        }
        const filePath = params.file_path;
        if (!path.isAbsolute(filePath)) {
            return `File path must be absolute: ${filePath}`;
        }
        const workspaceContext = this.config.getWorkspaceContext();
        if (!workspaceContext.isPathWithinWorkspace(filePath)) {
            const directories = workspaceContext.getDirectories();
            return `File path must be within one of the workspace directories: ${directories.join(', ')}`;
        }
        try {
            // This check should be performed only if the path exists.
            // If it doesn't exist, it's a new file, which is valid for writing.
            if (fs.existsSync(filePath)) {
                const stats = fs.lstatSync(filePath);
                if (stats.isDirectory()) {
                    return `Path is a directory, not a file: ${filePath}`;
                }
            }
        }
        catch (statError) {
            // If fs.existsSync is true but lstatSync fails (e.g., permissions, race condition where file is deleted)
            // this indicates an issue with accessing the path that should be reported.
            return `Error accessing path properties for validation: ${filePath}. Reason: ${statError instanceof Error ? statError.message : String(statError)}`;
        }
        return null;
    }
    getDescription(params) {
        if (!params.file_path) {
            return `Model did not provide valid parameters for write file tool, missing or empty "file_path"`;
        }
        const relativePath = makeRelative(params.file_path, this.config.getTargetDir());
        return `Writing to ${shortenPath(relativePath)}`;
    }
    /**
     * Handles the confirmation prompt for the WriteFile tool.
     */
    async shouldConfirmExecute(params, abortSignal) {
        if (this.config.getApprovalMode() === ApprovalMode.AUTO_EDIT) {
            return false;
        }
        const validationError = this.validateToolParams(params);
        if (validationError) {
            return false;
        }
        const correctedContentResult = await this._getCorrectedFileContent(params.file_path, params.content, abortSignal);
        if (correctedContentResult.error) {
            // If file exists but couldn't be read, we can't show a diff for confirmation.
            return false;
        }
        const { originalContent, correctedContent } = correctedContentResult;
        const relativePath = makeRelative(params.file_path, this.config.getTargetDir());
        const fileName = path.basename(params.file_path);
        const fileDiff = Diff.createPatch(fileName, originalContent, // Original content (empty if new file or unreadable)
        correctedContent, // Content after potential correction
        'Current', 'Proposed', DEFAULT_DIFF_OPTIONS);
        const ideClient = this.config.getIdeClient();
        const ideConfirmation = this.config.getIdeMode() &&
            ideClient.getConnectionStatus().status === IDEConnectionStatus.Connected
            ? ideClient.openDiff(params.file_path, correctedContent)
            : undefined;
        const confirmationDetails = {
            type: 'edit',
            title: `Confirm Write: ${shortenPath(relativePath)}`,
            fileName,
            filePath: params.file_path,
            fileDiff,
            originalContent,
            newContent: correctedContent,
            onConfirm: async (outcome) => {
                if (outcome === ToolConfirmationOutcome.ProceedAlways) {
                    this.config.setApprovalMode(ApprovalMode.AUTO_EDIT);
                }
                if (ideConfirmation) {
                    const result = await ideConfirmation;
                    if (result.status === 'accepted' && result.content) {
                        params.content = result.content;
                    }
                }
            },
            ideConfirmation,
        };
        return confirmationDetails;
    }
    async execute(params, abortSignal) {
        const validationError = this.validateToolParams(params);
        if (validationError) {
            return {
                llmContent: `Could not write file due to invalid parameters: ${validationError}`,
                returnDisplay: validationError,
                error: {
                    message: validationError,
                    type: ToolErrorType.INVALID_TOOL_PARAMS,
                },
            };
        }
        const correctedContentResult = await this._getCorrectedFileContent(params.file_path, params.content, abortSignal);
        if (correctedContentResult.error) {
            const errDetails = correctedContentResult.error;
            const errorMsg = errDetails.code
                ? `Error checking existing file '${params.file_path}': ${errDetails.message} (${errDetails.code})`
                : `Error checking existing file: ${errDetails.message}`;
            return {
                llmContent: errorMsg,
                returnDisplay: errorMsg,
                error: {
                    message: errorMsg,
                    type: ToolErrorType.FILE_WRITE_FAILURE,
                },
            };
        }
        const { originalContent, correctedContent: fileContent, fileExists, } = correctedContentResult;
        // fileExists is true if the file existed (and was readable or unreadable but caught by readError).
        // fileExists is false if the file did not exist (ENOENT).
        const isNewFile = !fileExists ||
            (correctedContentResult.error !== undefined &&
                !correctedContentResult.fileExists);
        try {
            const dirName = path.dirname(params.file_path);
            if (!fs.existsSync(dirName)) {
                fs.mkdirSync(dirName, { recursive: true });
            }
            fs.writeFileSync(params.file_path, fileContent, 'utf8');
            // Generate diff for display result
            const fileName = path.basename(params.file_path);
            // If there was a readError, originalContent in correctedContentResult is '',
            // but for the diff, we want to show the original content as it was before the write if possible.
            // However, if it was unreadable, currentContentForDiff will be empty.
            const currentContentForDiff = correctedContentResult.error
                ? '' // Or some indicator of unreadable content
                : originalContent;
            const fileDiff = Diff.createPatch(fileName, currentContentForDiff, fileContent, 'Original', 'Written', DEFAULT_DIFF_OPTIONS);
            const originallyProposedContent = params.ai_proposed_content || params.content;
            const diffStat = getDiffStat(fileName, currentContentForDiff, originallyProposedContent, params.content);
            const llmSuccessMessageParts = [
                isNewFile
                    ? `Successfully created and wrote to new file: ${params.file_path}.`
                    : `Successfully overwrote file: ${params.file_path}.`,
            ];
            if (params.modified_by_user) {
                llmSuccessMessageParts.push(`User modified the \`content\` to be: ${params.content}`);
            }
            const displayResult = {
                fileDiff,
                fileName,
                originalContent: correctedContentResult.originalContent,
                newContent: correctedContentResult.correctedContent,
                diffStat,
            };
            const lines = fileContent.split('\n').length;
            const mimetype = getSpecificMimeType(params.file_path);
            const extension = path.extname(params.file_path); // Get extension
            if (isNewFile) {
                recordFileOperationMetric(this.config, FileOperation.CREATE, lines, mimetype, extension, diffStat);
            }
            else {
                recordFileOperationMetric(this.config, FileOperation.UPDATE, lines, mimetype, extension, diffStat);
            }
            return {
                llmContent: llmSuccessMessageParts.join(' '),
                returnDisplay: displayResult,
            };
        }
        catch (error) {
            // Capture detailed error information for debugging
            let errorMsg;
            let errorType = ToolErrorType.FILE_WRITE_FAILURE;
            if (isNodeError(error)) {
                // Handle specific Node.js errors with their error codes
                errorMsg = `Error writing to file '${params.file_path}': ${error.message} (${error.code})`;
                // Log specific error types for better debugging
                if (error.code === 'EACCES') {
                    errorMsg = `Permission denied writing to file: ${params.file_path} (${error.code})`;
                    errorType = ToolErrorType.PERMISSION_DENIED;
                }
                else if (error.code === 'ENOSPC') {
                    errorMsg = `No space left on device: ${params.file_path} (${error.code})`;
                    errorType = ToolErrorType.NO_SPACE_LEFT;
                }
                else if (error.code === 'EISDIR') {
                    errorMsg = `Target is a directory, not a file: ${params.file_path} (${error.code})`;
                    errorType = ToolErrorType.TARGET_IS_DIRECTORY;
                }
                // Include stack trace in debug mode for better troubleshooting
                if (this.config.getDebugMode() && error.stack) {
                    console.error('Write file error stack:', error.stack);
                }
            }
            else if (error instanceof Error) {
                errorMsg = `Error writing to file: ${error.message}`;
            }
            else {
                errorMsg = `Error writing to file: ${String(error)}`;
            }
            return {
                llmContent: errorMsg,
                returnDisplay: errorMsg,
                error: {
                    message: errorMsg,
                    type: errorType,
                },
            };
        }
    }
    async _getCorrectedFileContent(filePath, proposedContent, abortSignal) {
        let originalContent = '';
        let fileExists = false;
        let correctedContent = proposedContent;
        try {
            originalContent = fs.readFileSync(filePath, 'utf8');
            fileExists = true; // File exists and was read
        }
        catch (err) {
            if (isNodeError(err) && err.code === 'ENOENT') {
                fileExists = false;
                originalContent = '';
            }
            else {
                // File exists but could not be read (permissions, etc.)
                fileExists = true; // Mark as existing but problematic
                originalContent = ''; // Can't use its content
                const error = {
                    message: getErrorMessage(err),
                    code: isNodeError(err) ? err.code : undefined,
                };
                // Return early as we can't proceed with content correction meaningfully
                return { originalContent, correctedContent, fileExists, error };
            }
        }
        // If readError is set, we have returned.
        // So, file was either read successfully (fileExists=true, originalContent set)
        // or it was ENOENT (fileExists=false, originalContent='').
        if (fileExists) {
            // This implies originalContent is available
            const { params: correctedParams } = await ensureCorrectEdit(filePath, originalContent, {
                old_string: originalContent, // Treat entire current content as old_string
                new_string: proposedContent,
                file_path: filePath,
            }, this.config.getGeminiClient(), abortSignal);
            correctedContent = correctedParams.new_string;
        }
        else {
            // This implies new file (ENOENT)
            correctedContent = await ensureCorrectFileContent(proposedContent, this.config.getGeminiClient(), abortSignal);
        }
        return { originalContent, correctedContent, fileExists };
    }
    getModifyContext(abortSignal) {
        return {
            getFilePath: (params) => params.file_path,
            getCurrentContent: async (params) => {
                const correctedContentResult = await this._getCorrectedFileContent(params.file_path, params.content, abortSignal);
                return correctedContentResult.originalContent;
            },
            getProposedContent: async (params) => {
                const correctedContentResult = await this._getCorrectedFileContent(params.file_path, params.content, abortSignal);
                return correctedContentResult.correctedContent;
            },
            createUpdatedParams: (_oldContent, modifiedProposedContent, originalParams) => {
                const content = originalParams.content;
                return {
                    ...originalParams,
                    ai_proposed_content: content,
                    content: modifiedProposedContent,
                    modified_by_user: true,
                };
            },
        };
    }
}
//# sourceMappingURL=write-file.js.map