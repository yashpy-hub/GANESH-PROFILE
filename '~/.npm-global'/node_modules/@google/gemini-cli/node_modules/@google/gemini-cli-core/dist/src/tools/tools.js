/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * A convenience base class for ToolInvocation.
 */
export class BaseToolInvocation {
    params;
    constructor(params) {
        this.params = params;
    }
    toolLocations() {
        return [];
    }
    shouldConfirmExecute(_abortSignal) {
        return Promise.resolve(false);
    }
}
/**
 * An adapter that wraps the legacy `Tool` interface to make it compatible
 * with the new `ToolInvocation` pattern.
 */
export class LegacyToolInvocation {
    legacyTool;
    params;
    constructor(legacyTool, params) {
        this.legacyTool = legacyTool;
        this.params = params;
    }
    getDescription() {
        return this.legacyTool.getDescription(this.params);
    }
    toolLocations() {
        return this.legacyTool.toolLocations(this.params);
    }
    shouldConfirmExecute(abortSignal) {
        return this.legacyTool.shouldConfirmExecute(this.params, abortSignal);
    }
    execute(signal, updateOutput) {
        return this.legacyTool.execute(this.params, signal, updateOutput);
    }
}
/**
 * New base class for tools that separates validation from execution.
 * New tools should extend this class.
 */
export class DeclarativeTool {
    name;
    displayName;
    description;
    kind;
    parameterSchema;
    isOutputMarkdown;
    canUpdateOutput;
    constructor(name, displayName, description, kind, parameterSchema, isOutputMarkdown = true, canUpdateOutput = false) {
        this.name = name;
        this.displayName = displayName;
        this.description = description;
        this.kind = kind;
        this.parameterSchema = parameterSchema;
        this.isOutputMarkdown = isOutputMarkdown;
        this.canUpdateOutput = canUpdateOutput;
    }
    get schema() {
        return {
            name: this.name,
            description: this.description,
            parametersJsonSchema: this.parameterSchema,
        };
    }
    /**
     * Validates the raw tool parameters.
     * Subclasses should override this to add custom validation logic
     * beyond the JSON schema check.
     * @param params The raw parameters from the model.
     * @returns An error message string if invalid, null otherwise.
     */
    validateToolParams(_params) {
        // Base implementation can be extended by subclasses.
        return null;
    }
    /**
     * A convenience method that builds and executes the tool in one step.
     * Throws an error if validation fails.
     * @param params The raw, untrusted parameters from the model.
     * @param signal AbortSignal for tool cancellation.
     * @param updateOutput Optional callback to stream output.
     * @returns The result of the tool execution.
     */
    async buildAndExecute(params, signal, updateOutput) {
        const invocation = this.build(params);
        return invocation.execute(signal, updateOutput);
    }
}
/**
 * New base class for declarative tools that separates validation from execution.
 * New tools should extend this class, which provides a `build` method that
 * validates parameters before deferring to a `createInvocation` method for
 * the final `ToolInvocation` object instantiation.
 */
export class BaseDeclarativeTool extends DeclarativeTool {
    build(params) {
        const validationError = this.validateToolParams(params);
        if (validationError) {
            throw new Error(validationError);
        }
        return this.createInvocation(params);
    }
}
/**
 * Base implementation for tools with common functionality
 * @deprecated Use `DeclarativeTool` for new tools.
 */
export class BaseTool extends DeclarativeTool {
    name;
    displayName;
    description;
    kind;
    parameterSchema;
    isOutputMarkdown;
    canUpdateOutput;
    /**
     * Creates a new instance of BaseTool
     * @param name Internal name of the tool (used for API calls)
     * @param displayName User-friendly display name of the tool
     * @param description Description of what the tool does
     * @param isOutputMarkdown Whether the tool's output should be rendered as markdown
     * @param canUpdateOutput Whether the tool supports live (streaming) output
     * @param parameterSchema JSON Schema defining the parameters
     */
    constructor(name, displayName, description, kind, parameterSchema, isOutputMarkdown = true, canUpdateOutput = false) {
        super(name, displayName, description, kind, parameterSchema, isOutputMarkdown, canUpdateOutput);
        this.name = name;
        this.displayName = displayName;
        this.description = description;
        this.kind = kind;
        this.parameterSchema = parameterSchema;
        this.isOutputMarkdown = isOutputMarkdown;
        this.canUpdateOutput = canUpdateOutput;
    }
    build(params) {
        const validationError = this.validateToolParams(params);
        if (validationError) {
            throw new Error(validationError);
        }
        return new LegacyToolInvocation(this, params);
    }
    /**
     * Validates the parameters for the tool
     * This is a placeholder implementation and should be overridden
     * Should be called from both `shouldConfirmExecute` and `execute`
     * `shouldConfirmExecute` should return false immediately if invalid
     * @param params Parameters to validate
     * @returns An error message string if invalid, null otherwise
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    validateToolParams(params) {
        // Implementation would typically use a JSON Schema validator
        // This is a placeholder that should be implemented by derived classes
        return null;
    }
    /**
     * Gets a pre-execution description of the tool operation
     * Default implementation that should be overridden by derived classes
     * @param params Parameters for the tool execution
     * @returns A markdown string describing what the tool will do
     */
    getDescription(params) {
        return JSON.stringify(params);
    }
    /**
     * Determines if the tool should prompt for confirmation before execution
     * @param params Parameters for the tool execution
     * @returns Whether or not execute should be confirmed by the user.
     */
    shouldConfirmExecute(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    params, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    abortSignal) {
        return Promise.resolve(false);
    }
    /**
     * Determines what file system paths the tool will affect
     * @param params Parameters for the tool execution
     * @returns A list of such paths
     */
    toolLocations(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    params) {
        return [];
    }
}
/**
 * Detects cycles in a JSON schemas due to `$ref`s.
 * @param schema The root of the JSON schema.
 * @returns `true` if a cycle is detected, `false` otherwise.
 */
export function hasCycleInSchema(schema) {
    function resolveRef(ref) {
        if (!ref.startsWith('#/')) {
            return null;
        }
        const path = ref.substring(2).split('/');
        let current = schema;
        for (const segment of path) {
            if (typeof current !== 'object' ||
                current === null ||
                !Object.prototype.hasOwnProperty.call(current, segment)) {
                return null;
            }
            current = current[segment];
        }
        return current;
    }
    function traverse(node, visitedRefs, pathRefs) {
        if (typeof node !== 'object' || node === null) {
            return false;
        }
        if (Array.isArray(node)) {
            for (const item of node) {
                if (traverse(item, visitedRefs, pathRefs)) {
                    return true;
                }
            }
            return false;
        }
        if ('$ref' in node && typeof node.$ref === 'string') {
            const ref = node.$ref;
            if (ref === '#/' || pathRefs.has(ref)) {
                // A ref to just '#/' is always a cycle.
                return true; // Cycle detected!
            }
            if (visitedRefs.has(ref)) {
                return false; // Bail early, we have checked this ref before.
            }
            const resolvedNode = resolveRef(ref);
            if (resolvedNode) {
                // Add it to both visited and the current path
                visitedRefs.add(ref);
                pathRefs.add(ref);
                const hasCycle = traverse(resolvedNode, visitedRefs, pathRefs);
                pathRefs.delete(ref); // Backtrack, leaving it in visited
                return hasCycle;
            }
        }
        // Crawl all the properties of node
        for (const key in node) {
            if (Object.prototype.hasOwnProperty.call(node, key)) {
                if (traverse(node[key], visitedRefs, pathRefs)) {
                    return true;
                }
            }
        }
        return false;
    }
    return traverse(schema, new Set(), new Set());
}
export var ToolConfirmationOutcome;
(function (ToolConfirmationOutcome) {
    ToolConfirmationOutcome["ProceedOnce"] = "proceed_once";
    ToolConfirmationOutcome["ProceedAlways"] = "proceed_always";
    ToolConfirmationOutcome["ProceedAlwaysServer"] = "proceed_always_server";
    ToolConfirmationOutcome["ProceedAlwaysTool"] = "proceed_always_tool";
    ToolConfirmationOutcome["ModifyWithEditor"] = "modify_with_editor";
    ToolConfirmationOutcome["Cancel"] = "cancel";
})(ToolConfirmationOutcome || (ToolConfirmationOutcome = {}));
export var Kind;
(function (Kind) {
    Kind["Read"] = "read";
    Kind["Edit"] = "edit";
    Kind["Delete"] = "delete";
    Kind["Move"] = "move";
    Kind["Search"] = "search";
    Kind["Execute"] = "execute";
    Kind["Think"] = "think";
    Kind["Fetch"] = "fetch";
    Kind["Other"] = "other";
})(Kind || (Kind = {}));
//# sourceMappingURL=tools.js.map